"""autogenerated by genpy from mk_msgs/sensorData.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class sensorData(genpy.Message):
  _md5sum = "7e8cef3e80536e777b04973b40e71d35"
  _type = "mk_msgs/sensorData"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header

float32 Longitude
float32 Latitude
float32 gpsAltitude

int32 SatsInUse
int32 NumberOfWPs
int32 CurrentWP
int32 ErrorCode
#int32 NCMode
#int32 FCMode1
#int32 FCMode2

int32 Free
int32 PH
int32 CH
int32 RangeLimit
int32 NoSerialLink
int32 TargetReached
int32 Manual
int32 GPSOK

int32 MotorsOn
int32 Flying
#int32 Calibrate
#int32 Start
#int32 EmergencyLanding
int32 LowBat
#int32 VarioTimUp
#int32 VarioTrimDown

int32 CareFree
int32 AltHld
int32 Failsafe 

float32 Altitude
float32 FlyingTime
float32 Battery
float32 GroundSpeed
float32 Heading
float32 CompassHeading
float32 Nick
float32 Roll
float32 RCQuality
float32 zSpeed
float32 TargetHoldTime
float32 Gas
float32 Current
float32 UsedCapacity


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

"""
  __slots__ = ['header','Longitude','Latitude','gpsAltitude','SatsInUse','NumberOfWPs','CurrentWP','ErrorCode','Free','PH','CH','RangeLimit','NoSerialLink','TargetReached','Manual','GPSOK','MotorsOn','Flying','LowBat','CareFree','AltHld','Failsafe','Altitude','FlyingTime','Battery','GroundSpeed','Heading','CompassHeading','Nick','Roll','RCQuality','zSpeed','TargetHoldTime','Gas','Current','UsedCapacity']
  _slot_types = ['std_msgs/Header','float32','float32','float32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,Longitude,Latitude,gpsAltitude,SatsInUse,NumberOfWPs,CurrentWP,ErrorCode,Free,PH,CH,RangeLimit,NoSerialLink,TargetReached,Manual,GPSOK,MotorsOn,Flying,LowBat,CareFree,AltHld,Failsafe,Altitude,FlyingTime,Battery,GroundSpeed,Heading,CompassHeading,Nick,Roll,RCQuality,zSpeed,TargetHoldTime,Gas,Current,UsedCapacity

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(sensorData, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.Longitude is None:
        self.Longitude = 0.
      if self.Latitude is None:
        self.Latitude = 0.
      if self.gpsAltitude is None:
        self.gpsAltitude = 0.
      if self.SatsInUse is None:
        self.SatsInUse = 0
      if self.NumberOfWPs is None:
        self.NumberOfWPs = 0
      if self.CurrentWP is None:
        self.CurrentWP = 0
      if self.ErrorCode is None:
        self.ErrorCode = 0
      if self.Free is None:
        self.Free = 0
      if self.PH is None:
        self.PH = 0
      if self.CH is None:
        self.CH = 0
      if self.RangeLimit is None:
        self.RangeLimit = 0
      if self.NoSerialLink is None:
        self.NoSerialLink = 0
      if self.TargetReached is None:
        self.TargetReached = 0
      if self.Manual is None:
        self.Manual = 0
      if self.GPSOK is None:
        self.GPSOK = 0
      if self.MotorsOn is None:
        self.MotorsOn = 0
      if self.Flying is None:
        self.Flying = 0
      if self.LowBat is None:
        self.LowBat = 0
      if self.CareFree is None:
        self.CareFree = 0
      if self.AltHld is None:
        self.AltHld = 0
      if self.Failsafe is None:
        self.Failsafe = 0
      if self.Altitude is None:
        self.Altitude = 0.
      if self.FlyingTime is None:
        self.FlyingTime = 0.
      if self.Battery is None:
        self.Battery = 0.
      if self.GroundSpeed is None:
        self.GroundSpeed = 0.
      if self.Heading is None:
        self.Heading = 0.
      if self.CompassHeading is None:
        self.CompassHeading = 0.
      if self.Nick is None:
        self.Nick = 0.
      if self.Roll is None:
        self.Roll = 0.
      if self.RCQuality is None:
        self.RCQuality = 0.
      if self.zSpeed is None:
        self.zSpeed = 0.
      if self.TargetHoldTime is None:
        self.TargetHoldTime = 0.
      if self.Gas is None:
        self.Gas = 0.
      if self.Current is None:
        self.Current = 0.
      if self.UsedCapacity is None:
        self.UsedCapacity = 0.
    else:
      self.header = std_msgs.msg.Header()
      self.Longitude = 0.
      self.Latitude = 0.
      self.gpsAltitude = 0.
      self.SatsInUse = 0
      self.NumberOfWPs = 0
      self.CurrentWP = 0
      self.ErrorCode = 0
      self.Free = 0
      self.PH = 0
      self.CH = 0
      self.RangeLimit = 0
      self.NoSerialLink = 0
      self.TargetReached = 0
      self.Manual = 0
      self.GPSOK = 0
      self.MotorsOn = 0
      self.Flying = 0
      self.LowBat = 0
      self.CareFree = 0
      self.AltHld = 0
      self.Failsafe = 0
      self.Altitude = 0.
      self.FlyingTime = 0.
      self.Battery = 0.
      self.GroundSpeed = 0.
      self.Heading = 0.
      self.CompassHeading = 0.
      self.Nick = 0.
      self.Roll = 0.
      self.RCQuality = 0.
      self.zSpeed = 0.
      self.TargetHoldTime = 0.
      self.Gas = 0.
      self.Current = 0.
      self.UsedCapacity = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3f18i14f.pack(_x.Longitude, _x.Latitude, _x.gpsAltitude, _x.SatsInUse, _x.NumberOfWPs, _x.CurrentWP, _x.ErrorCode, _x.Free, _x.PH, _x.CH, _x.RangeLimit, _x.NoSerialLink, _x.TargetReached, _x.Manual, _x.GPSOK, _x.MotorsOn, _x.Flying, _x.LowBat, _x.CareFree, _x.AltHld, _x.Failsafe, _x.Altitude, _x.FlyingTime, _x.Battery, _x.GroundSpeed, _x.Heading, _x.CompassHeading, _x.Nick, _x.Roll, _x.RCQuality, _x.zSpeed, _x.TargetHoldTime, _x.Gas, _x.Current, _x.UsedCapacity))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 140
      (_x.Longitude, _x.Latitude, _x.gpsAltitude, _x.SatsInUse, _x.NumberOfWPs, _x.CurrentWP, _x.ErrorCode, _x.Free, _x.PH, _x.CH, _x.RangeLimit, _x.NoSerialLink, _x.TargetReached, _x.Manual, _x.GPSOK, _x.MotorsOn, _x.Flying, _x.LowBat, _x.CareFree, _x.AltHld, _x.Failsafe, _x.Altitude, _x.FlyingTime, _x.Battery, _x.GroundSpeed, _x.Heading, _x.CompassHeading, _x.Nick, _x.Roll, _x.RCQuality, _x.zSpeed, _x.TargetHoldTime, _x.Gas, _x.Current, _x.UsedCapacity,) = _struct_3f18i14f.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3f18i14f.pack(_x.Longitude, _x.Latitude, _x.gpsAltitude, _x.SatsInUse, _x.NumberOfWPs, _x.CurrentWP, _x.ErrorCode, _x.Free, _x.PH, _x.CH, _x.RangeLimit, _x.NoSerialLink, _x.TargetReached, _x.Manual, _x.GPSOK, _x.MotorsOn, _x.Flying, _x.LowBat, _x.CareFree, _x.AltHld, _x.Failsafe, _x.Altitude, _x.FlyingTime, _x.Battery, _x.GroundSpeed, _x.Heading, _x.CompassHeading, _x.Nick, _x.Roll, _x.RCQuality, _x.zSpeed, _x.TargetHoldTime, _x.Gas, _x.Current, _x.UsedCapacity))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 140
      (_x.Longitude, _x.Latitude, _x.gpsAltitude, _x.SatsInUse, _x.NumberOfWPs, _x.CurrentWP, _x.ErrorCode, _x.Free, _x.PH, _x.CH, _x.RangeLimit, _x.NoSerialLink, _x.TargetReached, _x.Manual, _x.GPSOK, _x.MotorsOn, _x.Flying, _x.LowBat, _x.CareFree, _x.AltHld, _x.Failsafe, _x.Altitude, _x.FlyingTime, _x.Battery, _x.GroundSpeed, _x.Heading, _x.CompassHeading, _x.Nick, _x.Roll, _x.RCQuality, _x.zSpeed, _x.TargetHoldTime, _x.Gas, _x.Current, _x.UsedCapacity,) = _struct_3f18i14f.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_3I = struct.Struct("<3I")
_struct_3f18i14f = struct.Struct("<3f18i14f")
